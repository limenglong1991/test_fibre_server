#include <QCoreApplication>
#include <QThread>
#include <QDebug>
#include "my_thread.h"
#include "MotorControl/odrive_main.h"
#include "fibre/protocol.hpp"
#include <fibre/posix_tcp.hpp>
#include <fibre/posix_udp.hpp>

BoardConfig_t board_config;
Encoder::Config_t encoder_configs[AXIS_COUNT];
SensorlessEstimator::Config_t sensorless_configs[AXIS_COUNT];
Controller::Config_t controller_configs[AXIS_COUNT];
Motor::Config_t motor_configs[AXIS_COUNT];
Axis::Config_t axis_configs[AXIS_COUNT];
TrapezoidalTrajectory::Config_t trap_configs[AXIS_COUNT];
bool user_config_loaded_;

SystemStats_t system_stats_ = { 0 };

Axis *axes[AXIS_COUNT];

// the corresponding macros are defined in the autogenerated version.h
uint8_t fw_version_major = 1;
uint8_t fw_version_minor = 2;
uint8_t fw_version_revision = 3;
uint8_t fw_version_unreleased = 4; // 0 for official releases, 1 otherwise

volatile bool endpoint_list_valid = false;

static uint32_t test_property = 0;

/* Private function prototypes -----------------------------------------------*/

auto make_protocol_definitions(PWMMapping_t& mapping) {
    return make_protocol_member_list(
        make_protocol_property("endpoint", &mapping.endpoint),
        make_protocol_property("min", &mapping.min),
        make_protocol_property("max", &mapping.max)
    );
}

float oscilloscope[OSCILLOSCOPE_SIZE] = {0};
size_t oscilloscope_pos = 0;

// Helper class because the protocol library doesn't yet
// support non-member functions
// TODO: make this go away
class StaticFunctions {
public:
    void save_configuration_helper() {}
    void erase_configuration_helper() {}
    void NVIC_SystemReset_helper() {}
    void enter_dfu_mode_helper() {}
    float get_oscilloscope_val(uint32_t index) { return oscilloscope[index]; }
    float get_adc_voltage_(uint32_t gpio) {}
    int32_t test_function(int32_t delta) { static int cnt = 0; return cnt += delta; }
} static_functions;

// When adding new functions/variables to the protocol, be careful not to
// blow the communication stack. You can check comm_stack_info to see
// how much headroom you have.
static inline auto make_obj_tree() {
    return make_protocol_member_list(
        make_protocol_ro_property("fw_version_major", &fw_version_major),
        make_protocol_ro_property("fw_version_minor", &fw_version_minor),
        make_protocol_ro_property("fw_version_revision", &fw_version_revision),
        make_protocol_ro_property("fw_version_unreleased", &fw_version_unreleased),
        make_protocol_ro_property("user_config_loaded", const_cast<const bool *>(&user_config_loaded_)),
        make_protocol_object("system_stats",
            make_protocol_ro_property("uptime", &system_stats_.uptime),
            make_protocol_ro_property("min_heap_space", &system_stats_.min_heap_space),
            make_protocol_ro_property("min_stack_space_axis0", &system_stats_.min_stack_space_axis0),
            make_protocol_ro_property("min_stack_space_axis1", &system_stats_.min_stack_space_axis1),
            make_protocol_ro_property("min_stack_space_comms", &system_stats_.min_stack_space_comms),
            make_protocol_ro_property("min_stack_space_usb", &system_stats_.min_stack_space_usb),
            make_protocol_ro_property("min_stack_space_uart", &system_stats_.min_stack_space_uart),
            make_protocol_ro_property("min_stack_space_usb_irq", &system_stats_.min_stack_space_usb_irq),
            make_protocol_ro_property("min_stack_space_startup", &system_stats_.min_stack_space_startup)
            ),
        make_protocol_object("config",
            make_protocol_property("brake_resistance", &board_config.brake_resistance),
            make_protocol_property("enable_uart", &board_config.enable_uart),
            make_protocol_property("enable_i2c_instead_of_can" , &board_config.enable_i2c_instead_of_can), // requires a reboot
            make_protocol_property("enable_ascii_protocol_on_usb", &board_config.enable_ascii_protocol_on_usb),
            make_protocol_property("dc_bus_undervoltage_trip_level", &board_config.dc_bus_undervoltage_trip_level),
            make_protocol_property("dc_bus_overvoltage_trip_level", &board_config.dc_bus_overvoltage_trip_level),
            make_protocol_object("gpio1_pwm_mapping", make_protocol_definitions(board_config.analog_mappings[0])),
            make_protocol_object("gpio2_analog_mapping", make_protocol_definitions(board_config.analog_mappings[1]))
            ),
        make_protocol_object("axis0", axes[0]->make_protocol_definitions()),
        make_protocol_object("axis1", axes[1]->make_protocol_definitions()),
        make_protocol_function("test_function", static_functions, &StaticFunctions::test_function, "delta"),
        make_protocol_function("get_oscilloscope_val", static_functions, &StaticFunctions::get_oscilloscope_val, "index"),
        make_protocol_function("get_adc_voltage", static_functions, &StaticFunctions::get_adc_voltage_, "gpio"),
        make_protocol_function("save_configuration", static_functions, &StaticFunctions::save_configuration_helper),
        make_protocol_function("erase_configuration", static_functions, &StaticFunctions::erase_configuration_helper),
        make_protocol_function("reboot", static_functions, &StaticFunctions::NVIC_SystemReset_helper),
        make_protocol_function("enter_dfu_mode", static_functions, &StaticFunctions::enter_dfu_mode_helper)
    );
}

static void axis_thread(Axis *axis)
{
    run_state_machine_loop_wrapper(axis);
}

using tree_type = decltype(make_obj_tree());
uint8_t tree_buffer[sizeof(tree_type)];

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    for (size_t i = 0; i < AXIS_COUNT; ++i) {
        Encoder *encoder = new Encoder(encoder_configs[i]);
        SensorlessEstimator *sensorless_estimator = new SensorlessEstimator(sensorless_configs[i]);
        Controller *controller = new Controller(controller_configs[i]);
        Motor *motor = new Motor(motor_configs[i]);
        TrapezoidalTrajectory *trap = new TrapezoidalTrajectory(trap_configs[i]);
        axes[i] = new Axis(i, axis_configs[i],
                *encoder, *sensorless_estimator, *controller, *motor, *trap);
    }

    auto tree_ptr = new (tree_buffer) tree_type(make_obj_tree());
    fibre_publish(*tree_ptr);
    endpoint_list_valid = true;

    std::thread server_thread_tcp(serve_on_tcp, 9910);
    std::thread server_thread_udp(serve_on_udp, 9910);
//    my_thread *My_thread = new my_thread;
//    QThread *thread = new QThread;
//    My_thread->moveToThread(thread);
//    QCoreApplication::connect(thread, &QThread::started, My_thread, &my_thread::on_server);
//    thread->start();

    //axes[0]->controller_.set_current_setpoint(5.0);
    // Construct all objects.
    //axes[1]->run_state_machine_loop();

    std::thread server_axis0(axis_thread, axes[0]);
    std::thread server_axis1(axis_thread, axes[1]);
    return a.exec();
}
